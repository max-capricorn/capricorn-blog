(self.webpackChunkcapricorn_blog=self.webpackChunkcapricorn_blog||[]).push([[302],{6660:(a,e,n)=>{"use strict";n.r(e),n.d(e,{data:()=>l});const l={key:"v-8569aaa4",path:"/note/javascript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:3,title:"纯函数",slug:"纯函数",children:[]},{level:3,title:"幂等性",slug:"幂等性",children:[]},{level:3,title:"偏应用函数",slug:"偏应用函数",children:[]},{level:3,title:"柯里化函数",slug:"柯里化函数",children:[]},{level:3,title:"函数组合子",slug:"函数组合子",children:[]},{level:3,title:"惰性链",slug:"惰性链",children:[]},{level:3,title:"惰性函数",slug:"惰性函数",children:[]},{level:3,title:"惰性求值",slug:"惰性求值",children:[]},{level:3,title:"容器和函子",slug:"容器和函子",children:[]}],filePathRelative:"note/javascript/函数式编程.md",git:{updatedTime:1653289772e3,contributors:[]}}},104:(a,e,n)=>{"use strict";n.r(e),n.d(e,{default:()=>s});const l=(0,n(6252).uE)('<h3 id="纯函数" tabindex="-1"><a class="header-anchor" href="#纯函数" aria-hidden="true">#</a> 纯函数</h3><p>不仅有效降低系统的复杂度,还有很多很棒的特性, 比如可缓存性</p><h3 id="幂等性" tabindex="-1"><a class="header-anchor" href="#幂等性" aria-hidden="true">#</a> 幂等性</h3><p>指执行无数次还具有相同的结果,同一个参数运行一次函数应该与连续俩次结果一样, 幂等性在函数式编程与纯度相关,但不一致 比如:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="偏应用函数" tabindex="-1"><a class="header-anchor" href="#偏应用函数" aria-hidden="true">#</a> 偏应用函数</h3><ul><li>传递给函数一部分参数来调用它,让它返回一个函数去处理剩余的参数</li><li>偏函数之所以偏， 在于其只能处理那些能与一个case语句匹配的输入，而不能处理所有的输入</li></ul><h3 id="柯里化函数" tabindex="-1"><a class="header-anchor" href="#柯里化函数" aria-hidden="true">#</a> 柯里化函数</h3><ul><li>可以进行预加载</li></ul><h3 id="函数组合子" tabindex="-1"><a class="header-anchor" href="#函数组合子" aria-hidden="true">#</a> 函数组合子</h3><ul><li><p>compose函数只能组合接受一个参数的函数，类似于filter、map接受俩个参数(投影函数：总是在应用转换操作, 通过传入高阶函数后返回数组)，不能被直接组合可以借助偏函数包裹后继续组合</p></li><li><p>函数组合的数据流是从右向左，因为最右边的函数首先执行，将数据传递给下一个函数， 可以通过实现pipe让函数数据方向从左向右</p></li><li><p>因此需要组合子管理程序的控制流</p></li></ul><h3 id="惰性链" tabindex="-1"><a class="header-anchor" href="#惰性链" aria-hidden="true">#</a> 惰性链</h3><h3 id="惰性函数" tabindex="-1"><a class="header-anchor" href="#惰性函数" aria-hidden="true">#</a> 惰性函数</h3><h3 id="惰性求值" tabindex="-1"><a class="header-anchor" href="#惰性求值" aria-hidden="true">#</a> 惰性求值</h3><h3 id="容器和函子" tabindex="-1"><a class="header-anchor" href="#容器和函子" aria-hidden="true">#</a> 容器和函子</h3>',15),s={render:function(a,e){return l}}}}]);