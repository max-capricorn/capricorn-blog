(self.webpackChunkcapricorn_blog=self.webpackChunkcapricorn_blog||[]).push([[699],{2613:(e,a,n)=>{"use strict";n.r(a),n.d(a,{data:()=>s});const s={key:"v-0681ff8e",path:"/note/react/section1.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:3,title:"react15",slug:"react15",children:[]},{level:3,title:"react16",slug:"react16",children:[]},{level:3,title:"react17",slug:"react17",children:[]},{level:3,title:"react 17  reconciler",slug:"react-17-reconciler",children:[]},{level:3,title:"hooks 源码分析",slug:"hooks-源码分析",children:[]},{level:3,title:"简版的实现",slug:"简版的实现",children:[]}],filePathRelative:"note/react/section1.md",git:{updatedTime:1655882544e3,contributors:[]}}},9032:(e,a,n)=>{"use strict";n.r(a),n.d(a,{default:()=>t});const s=(0,n(6252).uE)('<h3 id="react15" tabindex="-1"><a class="header-anchor" href="#react15" aria-hidden="true">#</a> react15</h3><p>react16中以expirationTime的大小来衡量优先级, expirationTime越大, 优先级越高</p><h3 id="react16" tabindex="-1"><a class="header-anchor" href="#react16" aria-hidden="true">#</a> react16</h3><h3 id="react17" tabindex="-1"><a class="header-anchor" href="#react17" aria-hidden="true">#</a> react17</h3><h3 id="react-17-reconciler" tabindex="-1"><a class="header-anchor" href="#react-17-reconciler" aria-hidden="true">#</a> react 17 reconciler</h3><h4 id="大致的找到变化的组件的逻辑" tabindex="-1"><a class="header-anchor" href="#大致的找到变化的组件的逻辑" aria-hidden="true">#</a> 大致的找到变化的组件的逻辑</h4><p>react 发生一次更新的时候, 比如ReactDOM.reader/setState, 都会从Fiber Root 开始从上往下遍历，然后逐一找到变化的节点。构建完成会形成一颗Fiber Tree。 在react 内部会同时存在俩颗Fiber树。</p><h4 id="双缓存结构" tabindex="-1"><a class="header-anchor" href="#双缓存结构" aria-hidden="true">#</a> 双缓存结构</h4><p>在 React 中 最多会同时存在俩颗Fiber树。当前屏幕上显示内容对应的Fiber树成为current Fiber树，正在内存中构建的Fiber树 称为 workInProgress Fiber树。</p><p>current Fiber树 中的Fiber节点 被称为current fiber，workInProgress Fiber树 中的Fiber节点被称为 workInProgress fiber， 她们通过alternate 属性连接。</p><p>如果之前没有Fiber Tree 就逐级创建Fiber Tree； 如果存在Fiber Tree， 会构建一个WorkInProgress Tree， 这个tree 的Fiber节点可以服用current</p><h4 id="commit-阶段-负责将变化的组件渲染到页面上" tabindex="-1"><a class="header-anchor" href="#commit-阶段-负责将变化的组件渲染到页面上" aria-hidden="true">#</a> commit 阶段---负责将变化的组件渲染到页面上</h4><ul><li>commitBeforeMutationEffects （DOM操作前）</li><li>处理DOM节点 渲染/删除后的autoFocus、blur逻辑</li><li>调用getSnapshotBeforeUpdate 生命周期钩子</li><li>调度useEffect 也是一个异步的东西, 不会阻塞 useEffect ==&gt; componentDidMount</li></ul><h3 id="hooks-源码分析" tabindex="-1"><a class="header-anchor" href="#hooks-源码分析" aria-hidden="true">#</a> hooks 源码分析</h3><ol><li>为什么会有hooks？ 解决了什么样的问题？ class 组件只能通过props把state 传递过来 function Component 刚开始做UI组件 没有定义state的能力 function Component + hooks 可以做到更简洁 可以做到更方便的抽取逻辑</li><li>hooks 的基本用法 useContext + useReducer + context = redux useEffect 模拟生命周期 componentDidMount/didUpdate/willUnmount useMemo 缓存一个值 useCallback 缓存一个function useRef ref在function里使用 useState 定义state改变state的方式 hooks常见的几大问题: <ol><li>死循环</li><li>capture value 通过ref来解决</li></ol></li><li>hooks 的原理浅析 ReactFiberHooks.js</li><li>useState 的3个阶段 <ol><li>MountState</li><li>DispatchAction</li><li>UpdateState</li></ol></li><li>useEffect的俩个阶段 <ol><li>MountEffect</li><li>UpdateEffect</li></ol></li></ol><h3 id="简版的实现" tabindex="-1"><a class="header-anchor" href="#简版的实现" aria-hidden="true">#</a> 简版的实现</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>\n<span class="token keyword">let</span> state\n<span class="token keyword">const</span> <span class="token function-variable function">useState</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">defaultState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">newState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state <span class="token operator">=</span> newState\n  <span class="token punctuation">}</span>\n  \n  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state <span class="token operator">=</span> defautState\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div>',17),t={render:function(e,a){return s}}}}]);